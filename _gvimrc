"
" My VIM configuration
" Author  : Niklas Schultz
"

" ========================== MISC ==========================

" NOTE(nschultz): Startup message.
au VimEnter * :echo"\"The darker the night, the brighter the stars.\" - Fyodor Dostoevsky"

" NOTE(nschultz): Splits should always occupy 50% of the screen even when
" then window is being resized.
au VimResized * wincmd =

" NOTE(nschultz): Window dimensions on startup
" set lines=42
" set columns=140
" winpos 340 75
" au GUIEnter * :call libcallnr("gvimfullscreen_64.dll", "ToggleFullScreen", 0)
au GUIEnter * simalt ~x 

set nocompatible
set scrolloff=8
set backspace=indent,eol,start
set nohlsearch
set smartindent
set expandtab
set autoindent
set tabstop=4
set softtabstop=0 noexpandtab
set shiftwidth=4
set smartcase
set ignorecase
set belloff=all
set encoding=utf8
set mouse=a
set hidden
set noswapfile
set langmenu=en_US
let $LANG = 'en_US'

" NOTE(nschultz): netrw filebrowser stuff
let g:netrw_banner=0
let g:netrw_fastbrowse = 0
filetype plugin on
au FileType netrw setl bufhidden=wipe

" NOTE(nschultz): Build in fuzzy finder
set path+=**
set wildmenu
set wildignore+=*/tmp/*
set wildignore+=*.so/*
set wildignore+=*.swp
set wildignore+=*.zip
set wildignore+=*/vendor/*
set wildignore+=*/\.git/*
set wildignore+=*.class
set wildignore+=**/node_modules/**
set wildignore+=**/target/**

" NOTE(nschultz): Styling...
colorscheme midnight_oil
" TODO(nschultz): Why do I need this matching thing,
" even though I set the hi group inside the colorscheme???
au VimEnter,WinEnter * match Note /\<NOTE\>/

syntax on
set ruler
set rulerformat=
set guifont=Consolas:h13
" set guifont=Source_Code_Pro:h12
" set guifont=InputMono:h12
" set guifont=Consolas:h14
" set guifont=Source_Code_Pro:h12
" set guifont=Source_Code_Pro:h14
" set guifont=Droid_Sans_Mono:h12
" set rulerformat=%n%M%h%m%r%=%n\ %M\ 0x%B\ \ %l,%c%V\ %P
" set rulerformat=%M
set laststatus=2
set cmdheight=1
" NOTE(nschultz): Visual bell
au GUIEnter * set vb t_vb= 
set guioptions=-I
set guioptions-=L
set guioptions-=T
set guioptions-=m
" NOTE(nschultz): Use console dialogs instead of UI dialogs.
set guioptions+=c
" NOTE(nschultz): Instead of opening a dos an extra dos window
" when running an external command (e.g !git status) it will
" be shown in the output area at the bottom of gvim
set guioptions+=!
" NOTE(nschultz): When yanking the global clipboard of the system
" will be used. So no need to explicity yank into the '+' register.
set guioptions+=a
" NOTE(nschultz): dark variant for GUI?
" set guioptions+=
set guicursor=n-v-c:block-Cursor
set guicursor+=i:ver100-iCursor
set guicursor+=i:blinkon0
set guicursor+=a:blinkon0

" NOTE(nschultz): Reason for this double call is to act as a workaround when 
" sourcing this .rc file. If we do not do that then after sourcing the window
" is messed up and one have to retoggle fullscreen. This solution is of course not ideal
" but it works well enough.
" call libcallnr("gvimfullscreen_64.dll", "ToggleFullScreen", 0)
" call libcallnr("gvimfullscreen_64.dll", "ToggleFullScreen", 1)
map <F11> :call libcallnr("gvimfullscreen_64.dll", "ToggleFullScreen", 0)<CR>

" --------------------------------------------------------------------------

" NOTE(nschultz): Smoother scrolling
map <C-U> <C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y>
map <C-D> <C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E>

nnoremap <Up> <Nop>
nnoremap <Down> <Nop>
nnoremap <Left> <Nop>
nnoremap <Right> <Nop>
inoremap <Up> <Nop>
inoremap <Down> <Nop>
inoremap <Left> <Nop>
inoremap <Right> <Nop>
vnoremap <Up> <Nop>
vnoremap <Down> <Nop>
vnoremap <Left> <Nop>
vnoremap <Right> <Nop>
inoremap jj <ESC>
cnoremap jj <C-c> 
nnoremap j gj
nnoremap k gk
tnoremap jj <C-\><C-n>
nnoremap n nzz
nnoremap N Nzz

let mapleader = "\<Space>"
nnoremap <F5> :source $MYGVIMRC<CR>
nnoremap <F12> :e $MYGVIMRC<CR>
nnoremap <Leader><tab> :echo "Switching to buffer...?\n" <bar> :ls<CR>:buffer<Space>
" NOTE(nschultz): Faster compiling and running or applications:
nnoremap <Leader>m :!make<CR>
nnoremap <Leader>r :!make run<CR>
nnoremap <Leader>o :e <C-R>=expand("%:p:h") . "\\" <CR>
nnoremap <Leader>f :echo "Find file...\n"<CR>:find *
nnoremap <Leader>w :bn<CR>
" NOTE(nschultz): This function comes from my 'java_import_helper' plugin
nnoremap <Leader>, :call JavaImportHelper()<CR>

nnoremap <Leader>c :call CommentOut()<CR>
function! CommentOut()
	let last_pos = getpos(".")
	normal I//
	call setpos('.', last_pos)
endfunction

nnoremap <Leader>e :call ExecuteShellCommand()<CR>
function! ExecuteShellCommand()
	" TODO(nschultz): Would be even better If I just save
	" the current buffer id so I can specifically close this buffer 
	" again. No need to invent some crazy name to 'ensure' uniqueness.
	" We can use the following call for that:
	" let g:current_tmp_term_buf = bufnr("%")
	if has('terminal')
		let shell_cmd = input("Run shell command: ")
		if shell_cmd == ""
			return
		endif
		" NOTE(nschultz): Find out if we already have this type of terminal open.
		" If that is the case we will (force) delete it and then
		" create a new one. This saves us from having multiple terms
		" open.
		let prev_term_buf_id = bufnr("temporary_exec_terminal_1337")
		if prev_term_buf_id != -1
			execute 'bd! ' . prev_term_buf_id
		endif
		set termwinsize=8x0
		execute 'below terminal cmd /c ' . shell_cmd
		" NOTE(nschultz): Rename this buffer
		file temporary_exec_terminal_1337
	else
		echon "This functionality is not supported."
	endif
endfunction

nnoremap <Leader>d :call SearchInCurrentFile()<CR>
function! SearchInCurrentFile()
	if has('terminal')
		let what = input("Search in current file: ")
		if what == ""
			return
		endif
		" NOTE(nschultz): Find out if we already have this type of terminal open.
		" If that is the case we will (force) delete it and then
		" create a new one. This saves us from having multiple terms
		" open.
		let prev_term_buf_id = bufnr("temporary_searchfile_terminal_1337")
		if prev_term_buf_id != -1
			execute 'bd! ' . prev_term_buf_id
		endif
		set termwinsize=12x
		execute 'below terminal grep -in ' . what . ' ' . expand("%")
		" NOTE(nschultz): Rename this buffer
		file temporary_searchfile_terminal_1337
	else
		echon "This functionality is not supported."
	endif
endfunction

nnoremap <Leader>s :call SearchInCurrentLocation()<CR>
function! SearchInCurrentLocation()
	if has('terminal')
		let what = input("Search in current workspace: ")
		if what == ""
			return
		endif
		" NOTE(nschultz): Find out if we already have this type of terminal open.
		" If that is the case we will (force) delete it and then
		" create a new one. This saves us from having multiple terms
		" open.
		let prev_term_buf_id = bufnr("temporary_searchcwd_terminal_1337")
		if prev_term_buf_id != -1
			execute 'bd! ' . prev_term_buf_id
		endif
		set termwinsize=12x
		execute 'below terminal grep -irn ' . what . ' .'
		" NOTE(nschultz): Rename this buffer
		file temporary_searchcwd_terminal_1337
	else
		echon "This functionality is not supported."
	endif
endfunction

nnoremap <Leader>v :call SearchWordUnderCursorInCurrentWorkspace()<CR>
function! SearchWordUnderCursorInCurrentWorkspace()
	if has('terminal')
		" NOTE(nschultz): Find out if we already have this type of terminal open.
		" If that is the case we will (force) delete it and then
		" create a new one. This saves us from having multiple terms
		" open.
		let prev_term_buf_id = bufnr("temporary_searchwordcwd_terminal_1337")
		if prev_term_buf_id != -1
			execute 'bd! ' . prev_term_buf_id
		endif
		set termwinsize=12x
		let wrd = expand("<cword>")
		execute 'below terminal grep -irn ' . wrd . ' .'
		" NOTE(nschultz): Rename this buffer
		file temporary_searchwordcwd_terminal_1337
		echo wrd
	else
		echon "This functionality is not supported."
	endif
endfunction

nnoremap <Leader>q :call CloseCurrentBuffer()<CR>
function! CloseCurrentBuffer()
	if confirm('Force delete current buffer?', "&Yes\n&No", 1) == 1
		bd!
	endif
endfunction

nnoremap <Leader>0 :call ShowLeaderMappings()<CR>
function! ShowLeaderMappings()
	echon "Leader mappings:"
	map <leader>
endfunction

nnoremap <Leader>1 :call PrintNumberOfBuffers()<CR>
function! PrintNumberOfBuffers()
	let cnt = len(getbufinfo({'buflisted':1})) 
	echon "Current buffer count: '" . cnt . "'"
endfunction

nnoremap <Leader>2 :call PrintCWD()<CR>
function! PrintCWD()
	echon "Current working directory: "
	pwd
endfunction

nnoremap <Leader>3 :call ClearAndThenRedrawVim()<CR>
function! ClearAndThenRedrawVim()
	if confirm('Seeing something weird? Trigger full redraw?', "&Yes\n&No", 1) == 1
		redraw!
		echon "Done redrawing!"
	endif
endfunction

nnoremap <Leader>4 :call CountMatchesOfString()<CR>
function! CountMatchesOfString()
	let s:str = input("Count 'string' in buffer: ")
	if s:str == ""
		return
	endif
	execute '%s/' . s:str . '//gn'
endfunction

nnoremap <Leader>5 :call ReplaceAllInFile()<CR>
function! ReplaceAllInFile()
	let s:what = input("Replace: ")
	if s:what == ""
		return
	endif
	let s:with = input("With: ")
	if s:with == ""
		return
	endif
	execute '%s/' . s:what . '/' . s:with . '/g'
endfunction

nnoremap <Leader>6 :call CurrentTimeAndDate()<CR>
function! CurrentTimeAndDate()
	echon "Current time: "
	echon strftime("%c")
endfunction

nnoremap <Leader>8 :call ReloadAllBuffers()<CR>
function! ReloadAllBuffers()
	if confirm('Reload every buffer?' , "&Yes\n&No", 1) == 1
			bufdo e
	endif
endfunction

nnoremap <Leader>9 :call ResetVim()<CR>
function! ResetVim()
	if confirm('Confirm wiping every buffer?' , "&Yes\n&No", 1) == 1
		if confirm('Are you sure?' , "&Yes\n&No", 1) == 1
			bufdo bwipeout
			bufdo bd
		endif
	endif
endfunction

